function [ZI, MSEI, NMSEI, MSRI] = scalecInterpTile(x, z, s, xi, lx, filtername, nmseitol);%% [ZI, MSEI, NMSEI, MSRI] = scalecInterpTile(x, z, s, xi, lx, filtername, nmseitol);% catches regular grid output and breaks into bite-sized tiles % which are passed to scalecInterpPerturbations (which does not remove any trend)% % Input%   x, the nxm location of the data- repeated indices not handled well (ignored)%   z, the observations%   s, the the observation errors (i.e., standard deviations, rms, etc.)%      s is used to weight the observations as 1/s%      choose s=0 if no information is available about the weights %   xi, the interpolation locations%   lx, the interpolation weighting length scales%   filtername, the name of a filter to analyze:%      'quadloess'%      'linloess'%      'hanning'%      'boxcar'%   nmseitol, a maximum error level, if exceeded causes doubling of smoothing scales%       NOTE: if nmseitol=1 then this means we accept result with input scales%             if nmseitol<1 then this means interpolation will successive doubling of scales to reach desired noise reduction% % Output%   zi, the estimate%   msei, the mean square interpolation error estimate (units of z)%   nmsei, the normalized mean square error%   msri, the mean square residuals% catch  inputWB = [];[Ni,mi] = size(xi);if(~exist('nmseitol'))    %nmseitol = inf; % never invoke tolerance    nmseitol = 1./(mi^2); % default tol ensures some data used    fprintf('scalecInterpTile: setting maximum nmsei tolerance to %.3f\n', nmseitol)end    % detect gridded data idxi = find(xi(:,1)==xi(1,1));idyi = find(xi(:,2)==xi(1,2));% if second occurrance of x(1) coincides with end of occurrances of y(1), suspect gridded datatry    if((idyi(2)-1)==idxi(end))        fprintf('gridded output suspected\n');    endcatch    [ZI, MSEI, NMSEI, MSRI] = scalecInterp(x, z, s, xi, lx, filtername, nmseitol);    return;endnyi = idxi(end);nxi = Ni/nyi;% modify to handle time input for single time output on 2-d-h gridif (nxi~=fix(nxi))    fprintf('indices not consistent with gridded output, continuing to interp\n')    % pass to scalecinterp    [ZI, MSEI, NMSEI, MSRI] = scalecInterp(x, z, s, xi, lx, filtername, nmseitol);    return;else    % we still think we have gridded data    Xi = reshape(xi(:,1),nyi,nxi);    Yi = reshape(xi(:,2),nyi,nxi);    % and we are requesting single time        if(mi==3 & all(xi(:,3)==xi(1,3)))        Ti = xi(1,3);    end    xitest = Xi(1,:);    yitest = Yi(:,1);    [Xitest, Yitest] = meshgrid(xitest,yitest);    % check carefully and pass to scalecInterp if fail    if(~all(Xi==Xitest & Yi==Yitest))        fprintf('inidices not consistent with gridded output, continuing to interp\n')        % pass to scalecinterp        [ZI, MSEI, NMSEI, MSRI] = scalecInterp(x, z, s, xi, lx, filtername, nmseitol);        return;    endend% if we survived to here, we have gridded output% xi and yi are now row,col vectors of grid indicesxi = xitest;yi = yitest;clear xitest yitest Xitest Yitest% fix up input data[N,m] = size(x);% deal with nansid = find(isfinite(sum([x,z,s],2)));x=x(id,:);z = z(id);s = s(id);if(length(lx)==N & length(lx)~=Ni)    % got to remove the corresponding scales    lx = lx(id,:);end[N,m] = size(x);% need to remove trend once, % first, shift and scale grid and data% shift, center on output centermean_xi = mean(xi);mean_yi = mean(yi);xi = xi - mean_xi;yi = yi - mean_yi;Xi = Xi - mean_xi;Yi = Yi - mean_yi;x(:,1) = x(:,1) - repmat(mean_xi, N,1);x(:,2) = x(:,2) - repmat(mean_yi, N,1);% scalestd_x = std(x);id =find(std_x==0);if(length(id)>0) % catch variables with zero variance (e.g., a profile)    std_x(id) = 1+0*id;endL = diag(1./std_x);x = x*L;xi = xi*L(1,1);yi = yi*L(2,2);Xi = Xi*L(1,1);Yi = Yi*L(2,2);lx = lx*L;% add timeif(mi==3)    Ti = Ti*L(3,3);end% need some consistent weightswtol = 0.01;[wt, var_z] = consistentWeight(z, s.^2, wtol);% do regression to remove a norm fieldbtrend = zeros(mi+1,1);bi = btrend;% only compute against variables with variancevarid = find(std_x>0);if(length(varid>0))    % this is just for getting the data ready, so it is meant to be bullet proof, not statistically pure!    [btrend([1,varid+1]),bi([1,varid+1])] = regr_xzw([ones(N,1),x(:,varid)], z, wt);    fprintf('removed order %d polynomial\n', 1);end% regression failed if nanif(any(isnan(btrend)))    % pad with zero    btrend = zeros(length(btrend),1);endztrend = [ones(N,1),x]*btrend;% compute deviations from trendz = z - ztrend;% clear up memoryclear ztrend;% sort out the lx inputif (length(lx(:))==mi)    % same everywhere    lxflag = 'constant';elseif(length(lx(:,1))==Ni)    lxflag = 'ongrid';    lxgrid = reshape(lx(:,1), nyi,nxi);    lygrid = reshape(lx(:,2), nyi,nxi);else    % assume on data    lxflag = 'ondata';end% get optimal tile% first compute smoothness/domain size ratiolk=max([min(lx(:,1)), min(lx(:,2))]./[max(xi)-min(xi), max(yi)-min(yi)]);% next, the optimal number of tileskopt = sqrt(nxi*nyi*(1+lk));ropt = (1/kopt) + kopt/((1+lk)*nxi*nyi);kx = fix(sqrt(kopt)); % number of tiles in x,y dimsky = fix(sqrt(kopt));fprintf('number of tiles = %d, expected effiency =%.2g\n', kx*ky, ropt)nkx = fix(nxi/kx); % points per tile, roughlynky = fix(nyi/ky);% specify overlapLMAX = 10*[max(lx(:,1)),max(lx(:,2))];% init outputZI = nan*ones(nyi,nxi);NMSEI = ones(nyi,nxi);MSEI = ZI;MSRI = ZI;% show progressif 0==1    subplot 121;    hp1 = imagesc(xi, yi, ZI);    subplot 122;    hp2 = imagesc(xi, yi, NMSEI);    caxis([0 1])endNdone = 0;tstart = clock;for i=1:kx    idxi = [1:nkx] + (i-1)*nkx; % indices to interp this time    if(i==kx & idxi(end)~=nxi)        idxi = [idxi(1):nxi]; % catch the end here    end    % what is appropriate overlap?    xmin = xi(idxi(1))-LMAX(1); % find tile limits    xmax = xi(idxi(end))+LMAX(1);    idx = find(x(:,1)<xmax & x(:,1)>xmin); % get the useful data    if(length(idxi)>0)        % repeat at each yi        for j=1:ky            idyi = [1:nky] + (j-1)*nky; % indices to interp this time            if(j==ky & idyi(end)~=nyi)                idyi = [idyi(1):nyi]; % catch the end here            end            ymin = yi(idyi(1))-LMAX(2);            ymax = yi(idyi(end))+LMAX(2);            idxy = idx(find(x(idx,2)<ymax & x(idx,2)>ymin)); % get the useful data            if(length(idxy)>mi)                % send to interpolator                Xii = Xi(idyi,idxi);                Yii = Yi(idyi,idxi);                % deal with smoothing scales                switch lxflag                    case 'constant'                        L = lx;                    case 'ongrid'                        lxii = lxgrid(idyi,idxi);                        lyii = lygrid(idyi,idxi);                        L = [lxii(:), lyii(:)];                    case 'ondata'                        L = lx(idxy,:);                end                % now, send to interp                %[zi, msei, nmsei, msri] = scalecInterp(x(idxy,:), z(idxy), s(idxy), [Xii(:), Yii(:)], L, filtername, nmseitol);                % send to version that does not remove a trend                if(mi==2)                    [zi, msei, nmsei, msri, WB] = scalecInterpPerturbations(x(idxy,:), z(idxy), s(idxy), [Xii(:), Yii(:)], L, filtername, nmseitol, Ni, Ndone, WB);                    % put trend back into this tile                    zi = zi + [ones(size(Xii(:))), Xii(:), Yii(:)]*btrend;                elseif(mi==3)                    [zi, msei, nmsei, msri, WB] = scalecInterpPerturbations(x(idxy,:), z(idxy), s(idxy), [Xii(:), Yii(:), Ti+0*Xii(:)], L, filtername, nmseitol, Ni, Ndone, WB);                    % put trend back into this tile                    zi = zi + [ones(size(Xii(:))), Xii(:), Yii(:), Ti+0*Xii(:)]*btrend;                end                ZI(idyi,idxi) = reshape(zi, length(idyi), length(idxi));                MSEI(idyi,idxi) = reshape(msei, length(idyi), length(idxi));                NMSEI(idyi,idxi) = reshape(nmsei, length(idyi), length(idxi));                MSRI(idyi,idxi) = reshape(msri, length(idyi), length(idxi));                %set(hp1, 'cdata', ZI);                %set(hp2, 'cdata', NMSEI);                %drawnow                Ndone = sum(~isnan(ZI(:)));            end%            fprintf('completed %d,%d of %d,%d\r', i,j, kx,ky)        end    endendtend = clock;fprintf('interpolated %d points per second (tiled)\n', fix(nyi*nxi/(etime(tend,tstart))))% return output in colsZI    = ZI(:);MSEI  = MSEI(:);NMSEI = NMSEI(:);MSRI  = MSRI(:);% insert trend where no result existsid = find(isnan(ZI));if(mi==2)    ZI(id) = [ones(length(id),1), Xi(id), Yi(id)]*btrend;elseif(mi==3)    ZI(id) = [ones(length(id),1), Xi(id), Yi(id), 0*Xi(id)+Ti]*btrend;end% fix up error tooid = find(isnan(MSEI));MSEI(id) = var_z + mean(s.^2);MSRI(id) = MSEI(id);% clean up any waitbars that we generatedf=findobj(allchild(0),'flat','Tag','TMWWaitbar');if length(f)    close(f);end