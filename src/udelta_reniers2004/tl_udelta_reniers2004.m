function [tl_udelta,tl_delta]=tl_udelta_reniers2004(tl_ubar,tl_k,tl_omega,tl_h,tl_Hrms,tl_detady,tl_tau_wind,tl_Dr,tl_fv,tl_ks,tl_d50,bkgd)%,outvar)
%
% TL-code for udelta_reniers2004.m
%
% note, 'bkgd' struct should be taken from 2nd output of
% udelta_reniers2004.m, this contains the NL calculated variables

physicalConstants;

% other fixed params
kappa=0.4;  % von karman
cd=0.002;   % stated in text
fdelta=3;   % stated in text
nintegral=100;  % number of gridpionts for sigma-integration

% % v1, break out NL background vars. This version uses eval() and is a bit slow.
% fld=fields(bkgd);
% for i=1:length(fld)
%   eval([fld{i} ' = bkgd.' fld{i} ';']);
% end

% v2, Break out NL background vars. Note this hard-coded version runs
% significantly faster than if I use eval() to dynamically load all bkgd
% variables
ubar        =bkgd.ubar        ;
k           =bkgd.k           ;
omega       =bkgd.omega       ;
h           =bkgd.h           ;
Hrms        =bkgd.Hrms        ;
detady      =bkgd.detady      ;
Dr          =bkgd.Dr          ;
fv          =bkgd.fv          ;
kabs        =bkgd.kabs        ;
A           =bkgd.A           ;
uorb        =bkgd.uorb        ;
ks          =bkgd.ks          ;
z0          =bkgd.z0          ;
fw          =bkgd.fw          ;
Df          =bkgd.Df          ;
nubar_tb    =bkgd.nubar_tb    ;
Hm0         =bkgd.Hm0         ;
ht          =bkgd.ht          ;
p1          =bkgd.p1          ;
delta       =bkgd.delta       ;
phi_b       =bkgd.phi_b       ;
tau_wind    =bkgd.tau_wind    ;
tau_wind    =bkgd.tau_wind    ;
tau_wave    =bkgd.tau_wave    ;
tau_t       =bkgd.tau_t       ;
nubar_tflow =bkgd.nubar_tflow ;
abs_tau_wind=bkgd.abs_tau_wind;
nubar_twind =bkgd.nubar_twind ;
nubar_twave =bkgd.nubar_twave ;
nubar_t     =bkgd.nubar_t     ;
nu_tsurf    =bkgd.nu_tsurf    ;
sig_s       =bkgd.sig_s       ;
phi_s       =bkgd.phi_s       ;
nums        =bkgd.nums        ;
dens        =bkgd.dens        ;
sig_b       =bkgd.sig_b       ;
sig_0       =bkgd.sig_0       ;
l1d         =bkgd.l1d         ;
l2d         =bkgd.l2d         ;
Ab          =bkgd.Ab          ;
Bbp         =bkgd.Bbp         ;
Cbp         =bkgd.Cbp         ;
Am          =bkgd.Am          ;
alphab_bar  =bkgd.alphab_bar  ;
betab_bar   =bkgd.betab_bar   ;
alpham_bar  =bkgd.alpham_bar  ;
betam_bar   =bkgd.betam_bar   ;
alpha_bar   =bkgd.alpha_bar   ;
beta_bar    =bkgd.beta_bar    ;
F           =bkgd.F           ;
Bb          =bkgd.Bb          ;
Cb          =bkgd.Cb          ;
udelta      =bkgd.udelta      ;

%---------------------------------
% begin TL code
%---------------------------------

% derived params.  See notes here:
% ./reniers2004_solver_notes/reniers2004_formulaTree.sla
tl_kabs=1./kabs.*(k(1).*tl_k(1)+k(2).*tl_k(2));
tl_A=tl_Hrms./(2*sinh(kabs.*h)) ...
     - Hrms./(2*sinh(kabs.*h)).^2*2.*cosh(kabs.*h).*(tl_kabs.*h+kabs.*tl_h); % ok2
tl_uorb=tl_A*omega + A*tl_omega;
tl_z0=tl_ks/33; % ok2
tl_fw=1.39*( -.52*(A./z0).^(-.52-1).*( tl_A./z0 - A./z0.^2.*tl_z0 ) ); % ok2
tl_Df=1/(2*sqrt(pi))*rho*( tl_fw.*uorb.^3 + 3*fw.*uorb.^2.*tl_uorb ); % ok2
tl_nubar_tb= 2*fw.*uorb.^2/(4*omega).*tl_fw ...
    + 2*fw.^2.*uorb/(4*omega).*tl_uorb ...
    - fw.^2.*uorb.^2/4/omega^2*tl_omega;
tl_Hm0=tl_Hrms*1.4;  % ok2
tl_ht=tl_h-tl_Hm0/2;  % ok2
tl_p1=.82*(A./ks).^(.82-1).*( tl_A/ks - A./ks^2*tl_ks ); % ok2
tl_delta=fdelta*0.09*( tl_p1.*ks./ht ...
                       + p1.*tl_ks./ht ...
                       - p1.*ks./ht.^2.*tl_ht ); % ok2
tl_phi_b=-2*6./delta.^3.*tl_delta; % ok2
tl_tau_wave = tl_Dr.*k/omega ...
    + Dr.*tl_k/omega ...
    - Dr.*k/omega^2*tl_omega;
tl_tau_t=tl_tau_wind+tl_tau_wave;  % ok2
if(abs(detady)==0 | ht==0)
  tl_nubar_tflow=0;
else
  tl_nubar_tflow = 1/6*kappa*( ...
      tl_ht.*sqrt(g*ht.*abs(detady)) ...
      + g*.5*ht./sqrt(g*ht.*abs(detady)).*( tl_ht.*abs(detady) ...
                                            + ht.*tl_detady ) ); % ok2
end
if(tau_wind(1).^2 + tau_wind(2).^2 ==0)
  tl_abs_tau_wind=0;
else
  tl_abs_tau_wind = 1./sqrt( tau_wind(1).^2 + tau_wind(2).^2 ).*( ...
      tau_wind(1).*tl_tau_wind(1) + tau_wind(2).*tl_tau_wind(2) ); % ok2
end
if(abs_tau_wind==0)
  tl_nubar_twind=0;
else
  tl_nubar_twind = 1/3*kappa*( ...
      tl_ht.*sqrt(abs_tau_wind/rho) ...
      + .5/rho*ht./sqrt(abs_tau_wind/rho).*tl_abs_tau_wind ); % ok2
end
tl_nubar_twave = tl_fv*Hrms.*(Dr/rho).^(1/3) ...
    + fv*( tl_Hrms.*(Dr/rho).^(1/3) ...
           + 1/3/rho*Hrms.*(Dr/rho).^(1/3-1).*tl_Dr ); % ok2
if(nubar_t==0)
  tl_nubar_t=0;
else
  tl_nubar_t = 1./nubar_t.*( nubar_tflow.*tl_nubar_tflow ...
                             + nubar_twind.*tl_nubar_twind ...
                             + nubar_twave.*tl_nubar_twave ); % ok2
end
if(nubar_twind.^2+nubar_twave.^2==0)
  tl_nu_tsurf=0;
else
  tl_nu_tsurf = 3/2./sqrt( nubar_twind.^2 + nubar_twave.^2 ).*( ...
      nubar_twind.*tl_nubar_twind ...
      + nubar_twave.*tl_nubar_twave ); % ok2
end
tl_sig_s = ( tl_nubar_t - 1/3*tl_nu_tsurf ) ...
    ./( nubar_t - 1/2*nu_tsurf ) ...
    - ( nubar_t - 1/3*nu_tsurf )./( nubar_t - 1/2*nu_tsurf ).^2 ...
    .*( tl_nubar_t - 1/2*tl_nu_tsurf ); % ok2
tl_phi_s = -1./(sig_s/2-1/3).^2.*tl_sig_s/2; % ok2
tl_nums=tl_phi_s.*nubar_t.*sig_s ...
        + phi_s.*tl_nubar_t.*sig_s ...
        + phi_s.*nubar_t.*tl_sig_s ...
        + tl_phi_b.*nubar_tb.*delta ...
        + phi_b.*tl_nubar_tb.*delta ...
        + phi_b.*nubar_tb.*tl_delta; % ok2
tl_dens=tl_phi_s.*nubar_t ...
        + phi_s.*tl_nubar_t ...
        + tl_phi_b.*nubar_tb ...
        + phi_b.*tl_nubar_tb;  % ok2
tl_sig_b = tl_nums./dens ...
    - nums./dens.^2.*tl_dens; % ok2
tl_sig_0 = tl_z0./ht ...
    - z0./ht.^2.*tl_ht; % ok2

%--------------------------------------
% Solve for velocity at top of boundary layer, u_delta.  Refer to notes and
% derivations here: ./FgivenUbar_deriv/
%
% Need to do this for each gridpoint separately
%--------------------------------------

% define grid for integration over sigma coordinate
sgridb=linspace(sig_0,delta,nintegral);
dsb=diff(sgridb(1:2));
sgridm=linspace(delta,1,nintegral);
dsm=diff(sgridm(1:2));

tl_l1d=1./(delta./sig_0).*(tl_delta./sig_0-delta./sig_0.^2.*tl_sig_0); % ok2
tl_l2d=1./((sig_b-delta)./(sig_b-sig_0)).*( ...
    + (tl_sig_b-tl_delta)./(sig_b-sig_0) ...
    - (sig_b-delta)./(sig_b-sig_0).^2.*(tl_sig_b-tl_sig_0) ); % ok2
l1=log(sgridb./sig_0);
tl_l1=1./(sgridb./sig_0).*( - sgridb./sig_0.^2.*tl_sig_0 ); % ok2
dl1ds=1./sgridb; % ok2
l2=log((sig_b-sgridb)./(sig_b-sig_0));
tl_l2=1./((sig_b-sgridb)./(sig_b-sig_0)).*( ...
    tl_sig_b./(sig_b-sig_0) ...
    - (sig_b-sgridb)./(sig_b-sig_0).^2.*(tl_sig_b-tl_sig_0) ); % ok2
dl2ds=-1./(sig_b-sgridb); % ok
l3=log(sgridm./delta);
tl_l3=1./(sgridm./delta).*(-sgridm./delta.^2.*tl_delta); % ok2
l4=log((sig_s-sgridm)./(sig_s-delta));
tl_l4=1./((sig_s-sgridm)./(sig_s-delta)).*( ...
    + (tl_sig_s)./(sig_s-delta) ...
    - (sig_s-sgridm)./(sig_s-delta).^2.*(tl_sig_s-tl_delta) );  % ok2

for i=1:2

% coef functions for bottom boundary layer velocity profile, see
% ./FgivenUbar_deriv/part1_ubot/
tl_Ab(i)=tl_ht./(fv*rho.*phi_s.*nubar_t+rho*phi_b.*nubar_tb) ...
      - ht./(fv*rho.*phi_s.*nubar_t+rho*phi_b.*nubar_tb).^2.*( ...
          tl_fv*rho.*phi_s.*nubar_t ...
          + fv*rho.*tl_phi_s.*nubar_t ...
          + fv*rho.*phi_s.*tl_nubar_t ...
          + rho*tl_phi_b.*nubar_tb ...
          + rho*phi_b.*tl_nubar_tb ); % ok2
tl_Bbp(i)=tl_tau_t(i) ...
          + tl_Df.*k(i)/omega ...
          + Df.*tl_k(i)/omega ...
          - Df.*k(i)/omega^2*tl_omega;
tl_Cbp(i)=-tl_Df.*k(i)./(delta*omega) ...
          -Df.*tl_k(i)./(delta*omega) ...
          +Df.*k(i)./(delta*omega).^2.*(tl_delta*omega) ...
          + Df.*k(i)/delta/omega^2*tl_omega;

alphab=Ab(i).*( Bbp(i)./sig_b.*(l1-l2) - Cbp(i).*l2 );
tl_alphab=tl_Ab(i).*( Bbp(i)./sig_b.*(l1-l2) - Cbp(i).*l2 ) ...
          + Ab(i).*( tl_Bbp(i)./sig_b.*(l1-l2) ...
                  - Bbp(i)./sig_b^2.*(l1-l2).*tl_sig_b ...
                  + Bbp(i)./sig_b.*(tl_l1-tl_l2) ...
                  - tl_Cbp(i).*l2 ...
                  - Cbp(i).*tl_l2 ); % ok2
dalphabds=Ab(i).*( Bbp(i)./sig_b.*(dl1ds-dl2ds) + Cbp(i).*dl2ds ); % ok2
betab=Ab(i).*( -1/sig_b.*(l1-l2) - l2 );
tl_betab=tl_Ab(i).*( -1/sig_b.*(l1-l2) - l2 ) ...
         + Ab(i).*( +1/sig_b.^2.*(l1-l2).*tl_sig_b ...
                 -1/sig_b.*(tl_l1-tl_l2) ...
                 - tl_l2 ); % ok2
dbetabds=Ab(i).*( -1/sig_b.*(dl1ds-dl2ds) - dl2ds ); % ok2

% coef functions for mid-layer velocity profile, see
% ./FgivenUbar_deriv/part2_umid/.  Note these include terms that
% involve evaluation of alphab,betab at sigma=delta.
tl_Am(i)=tl_ht./(rho*phi_s.*nubar_t) ...
     - rho*ht./(rho*phi_s.*nubar_t).^2.*(tl_phi_s.*nubar_t + phi_s.*tl_nubar_t); % ok2
alpham=alphab(end) ...
       + Am(i).*( tau_t(i)./sig_s.*l3 - tau_t(i)./sig_s.*l4 );
tl_alpham=tl_alphab(end) ...
          + dalphabds(end).*tl_delta ...
          + tl_Am(i).*( tau_t(i)./sig_s.*l3 - tau_t(i)./sig_s.*l4 ) ...
          + Am(i).*( tl_tau_t(i)./sig_s.*l3 ...
                 - tau_t(i)./sig_s.^2.*l3.*tl_sig_s ...
                 + tau_t(i)./sig_s.*tl_l3 ...
                 - tl_tau_t(i)./sig_s.*l4 ...
                 - tau_t(i)./sig_s.*tl_l4 ...
                 + tau_t(i)./sig_s.^2.*l4.*tl_sig_s ); % ok2
betam=betab(end) ...
      + Am(i).*( -1./sig_s.*l3 + (1./sig_s-1).*l4 );
tl_betam=tl_betab(end) ...
         + dbetabds(end).*tl_delta ...
         + tl_Am(i).*( -1./sig_s.*l3 + (1./sig_s-1).*l4 ) ...
         + Am(i).*( +1./sig_s.^2.*l3.*tl_sig_s ...
                -1./sig_s.*tl_l3 ...
                + (-1./sig_s.^2.*tl_sig_s).*l4 ...
                + (1./sig_s-1).*tl_l4 ); % ok2

% define alpha_bar, beta_bar, coefficients for solution ubar.  See 
% ./FgivenUbar_deriv/part3_ubar/
%
% TL: dependences on limits of integration are approximated to first order
% by assuming the integrand is slowly varying near the limit of integration
tl_alphab_bar(i) = -alphab(1).*tl_sig_0 ...
    + alphab(end).*tl_delta ...
    + sum(tl_alphab)*dsb; % ok2
%    + trapz(sgridb,tl_alphab); % ok2
tl_betab_bar(i) = -betab(1).*tl_sig_0 ...
    + betab(end).*tl_delta ...
    + sum(tl_betab)*dsb; % ok2
%    + trapz(sgridb,tl_betab); % ok2
tl_alpham_bar(i) = -alpham(1).*tl_delta ...
    + sum(tl_alpham)*dsm; % ok2
%    + trapz(sgridm,tl_alpham); % ok2
tl_betam_bar(i)  = -betam(1).*tl_delta ...
    + sum(tl_betam)*dsm; % ok2
%    + trapz(sgridm,tl_betam); % ok2
tl_alpha_bar(i)  = tl_alphab_bar(i) + tl_alpham_bar(i); % ok2
tl_beta_bar(i)   = tl_betab_bar(i) + tl_betam_bar(i); % ok2

% solve for F
tl_F(i) = (tl_ubar(i) - tl_alpha_bar(i))./beta_bar(i) ...
       - (ubar(i) - alpha_bar(i))./beta_bar(i).^2.*tl_beta_bar(i); % ok2

% evaluate eqns (B9)-(B12) at sigma=delta to get u_delta
tl_Bb(i) = tl_tau_t(i) ...
    - tl_F(i) ...
    + tl_Df.*k(i)/omega ...
    + Df.*tl_k(i)/omega ...
    - Df.*k(i)/omega^2*tl_omega;
tl_Cb(i) = tl_F(i) ...
    - tl_Df.*k(i)./(delta.*omega) ...
    - Df.*tl_k(i)./(delta.*omega) ...
    + Df.*k(i)./(delta.*omega).^2.*(tl_delta*omega) ...
    + Df.*k(i)/delta/omega^2*tl_omega;
tl_udelta(i) = tl_Ab(i).*( Bb(i)./sig_b.*l1d ...
                     - (Bb(i)./sig_b+Cb(i)).*l2d ) ...
    + Ab(i).*( tl_Bb(i)./sig_b.*l1d ...
            - Bb(i)./sig_b.^2.*l1d.*tl_sig_b ...
            + Bb(i)./sig_b.*tl_l1d ...
            - (tl_Bb(i)./sig_b-Bb(i)./sig_b.^2.*tl_sig_b+tl_Cb(i)).*l2d ...
            - (Bb(i)./sig_b+Cb(i)).*tl_l2d ); % ok2

end

% % TEST
% eval(['tl_udelta=tl_' outvar ';']);
