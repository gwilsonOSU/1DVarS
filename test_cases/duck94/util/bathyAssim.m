function [params,diagnostics]=bathyAssim(bathyobs,priorCacheDir,bkgdCacheDir)
%
% [params,diagnostics]=bathyAssim(bathyobs,priorCacheDir,bkgdCacheDir)
%
% Phase-2 assimilation.  Use bathymetry observations to correct sediment
% transport parameters.
%
% INPUTS:
%
% bathyobs = bathymetry observations to be assimilated, produced by prepObsData.m
%
% priorCacheDir = directory containing structs of time-dependent model
%                 output files representing the prior.  The cached files are
%                 usually generated by hydroAssimLoop.m
%
% bkgdCacheDir = directory containing structs of time-dependent model output
%                files representing the background state. These cached files
%                are usually generated by hydroAssimLoop.m.
%
% OUTPUTS:
%
% params = updated sediment transport parameters after assimilating data
%
% (OPTIONAL) diagnostics = matrices and such used in assimilation
%

% prep params_std, allow for 'percError' percent error in all parameters.
% NOTE, the order of indexes in params_std is important, it must match the
% ordering convention used by paramsHandler.m
percError=0.1  % as a fraction, not percentage
bkgd1=load([priorCacheDir '/bkgd0001.mat']);
params=bkgd1.params;
if(strcmp(bkgd1.sedmodel,'vanderA'))
  params_std(1)=percError*params.fv   ;  % default params.fv    = 0.101
  params_std(2)=percError*params.ks   ;  % default params.ks    = 0.0082
  params_std(3)=percError*params.lambda; % default params.lambda= 1.57
  params_std(4)=percError*params.n    ;  % default params.n     = 1.2
  params_std(5)=percError*params.m    ;  % default params.m     = 11
  params_std(6)=percError*params.xi   ;  % default params.xi    = 1.7
  params_std(7)=percError*params.alpha;  % default params.alpha = 8.2
  if(isfield(params,'Cc'))
    params_std(8)=percError*params.Cc   ;  % default params.Cc    = 0.01
    params_std(9)=percError*params.Cf   ;  % default params.Cf    = 0.03
  end
elseif(strcmp(bkgd1.sedmodel,'dubarbier'))
  fld={'fv','ks','lambda','Cw','Cc','Cf','Ka'};
  for i=1:length(fld)
    params_std(i)=abs(getfield(params,fld{i}))*.1;
  end
else
  error(['sedmodel=' num2str(bkgd1.sedmodel) ' is not supported for full-run assimilation']);
end
Cd50=diag((.1*bkgd1.d50).^2);  % optional, allow for correction to d50
Cd50=0;  % disable d50 corrections
Cbeta0=0; %0.01;  % correction of beta0 (set to zero to disable)

% Init matrices needed for assimilation. Note dimensions of the full
% observation vector is no*nt x 1, where no is number of stations and nt
% is number of time points. I will break this out into a (no,nt) sized
% matrix, then later reshape it to no*nt x 1. Similar for other matrices.
% I list dimensions for each matrix below to reflect how things will later
% be reshaped in this fashion. Note I have ensured (above) that each time
% step always has the same number of observations (variable 'no')
modelnx=length(bkgd1.x);
obsnt=length(bathyobs);  % number of observation times
modelnt=max([bathyobs.obsn]);  % number of model time steps for a full run
obsno=length(bathyobs(1).measind);  % number of obs per time step, assumed same for all steps
modelnp=length(params_std)+1;  % +1 is for beta0
CMt =nan(modelnp,obsnt,obsno);  % np x (nt,no)
MCMt=nan(obsnt,obsno,obsnt,obsno);  % (nt,no) x (nt,no)
Mf  =nan(obsnt,obsno);  % (nt,no) x 1
d   =nan(obsnt,obsno);  % (nt,no) x 1
Cd  =nan(obsnt,obsno);  % (nt,no) x 1

% calculate representers for each observation [bathyobs.h]
for n=1:obsnt
  disp(['Computing representers for time step ' num2str(n) ' of ' num2str(obsnt)])
  disp(['  Start Time: ' datestr(now)])
  tic

  [~,parforCounterFile]=unix('mktemp');
  parforCounterFile=strtrim(parforCounterFile);
  starttime=now;
  clear MCMt_thisn  % parfor requires careful handling of MCMt
  pctRunOnAll warning('off','all')
  parfor i=1:obsno
    % if(floor(i/obsno*10)>floor((i-1)/obsno*10))
    %   disp(['  checkpoint ' num2str(floor(i/obsno*10)) ' of 10'])
    % end

    % initialize comb for observation of h at obs-gridpoint i and obs-time n
    ad_Hrms =zeros(modelnx,1);
    ad_theta=zeros(modelnx,1);
    ad_vbar =zeros(modelnx,1);
    ad_kabs =zeros(modelnx,1);
    ad_Qx   =zeros(modelnx,1);
    ad_h   =zeros(modelnx,modelnt+1);
    ad_h(bathyobs(n).measind(i),bathyobs(n).obsn+1)=1;  % comb

    % initialize adjoint outputs
    bkgd1=load([bkgdCacheDir '/bkgd0001.mat']);
    if(strcmp(bkgd1.sedmodel,'vanderA'))
      if(isfield(bkgd1.params,'Cc'))
        ad_params=paramsHandler(0,sedmodel,zeros(9,1));  % init ad_params struct to zero
      else
        ad_params=paramsHandler(0,sedmodel,zeros(7,1));  % init ad_params struct to zero
      end
    elseif(strcmp(bkgd1.sedmodel,'dubarbier'))
      ad_params=paramsHandler(0,bkgd1.sedmodel,zeros(7,1));  % init ad_params struct to zero
    end
    ad_ka_drag=0;
    ad_beta0  =0;
    ad_d50=zeros(modelnx,1);
    ad_d90=zeros(modelnx,1);
    ad_H0=zeros(modelnt,1);
    ad_theta0  =zeros(modelnt,1);
    ad_omega   =zeros(modelnt,1);
    ad_dgamma  =zeros(modelnx,modelnt);
    ad_dAw     =zeros(modelnx,modelnt);
    ad_dSw     =zeros(modelnx,modelnt);
    ad_tau_wind=zeros(modelnx,2,modelnt);
    ad_detady  =zeros(modelnx,modelnt);

    % propagate adjoint backwards from time bathyobs(n) to 1
    for n2=bathyobs(n).obsn:-1:1
      bkgdn2=load([bkgdCacheDir '/bkgd' num2str(n2,'%04d') '.mat']);
      bkgdn2.h=bkgdn2.h+bkgdn2.tide;
      bkgdn2.hp=bkgdn2.hp+bkgdn2.tide;
      [ad_h(:,n2),ad_H0(n2),ad_theta0(n2),ad_omega(n2),ad_ka_drag(n2),ad1_beta0,ad_tau_wind(:,:,n2),...
       ad_detady(:,n2),ad_dgamma(:,n2),ad_dAw(:,n2),ad_dSw(:,n2),...
       ad1_d50,ad1_d90,ad1_params] = ...
          ad_hydroSedModel(ad_Hrms,ad_vbar,ad_theta,ad_kabs,ad_Qx,ad_h(:,n2+1),bkgdn2);
      % ad_ka_drag     =ad_ka_drag     +ad1_ka_drag     ;
      ad_beta0       =ad_beta0       +ad1_beta0       ;
      ad_d50         =ad_d50         +ad1_d50         ;
      ad_d90         =ad_d90         +ad1_d90         ;
      ad_params.fv   =ad_params.fv   +ad1_params.fv   ;
      ad_params.ks   =ad_params.ks   +ad1_params.ks   ;
      ad_params.lambda=ad_params.lambda+ad1_params.lambda;
      if(strcmp(bkgdn2.sedmodel,'vanderA'))
        ad_params.n    =ad_params.n    +ad1_params.n    ;
        ad_params.m    =ad_params.m    +ad1_params.m    ;
        ad_params.xi   =ad_params.xi   +ad1_params.xi   ;
        ad_params.alpha=ad_params.alpha+ad1_params.alpha;
        if(isfield(bkgdn2.params,'Cc'))
          ad_params.Cc   =ad_params.Cc   +ad1_params.Cc   ;
          ad_params.Cf   =ad_params.Cf   +ad1_params.Cf   ;
        end
      elseif(strcmp(bkgdn2.sedmodel,'dubarbier'))
        ad_params.Cw = ad_params.Cw + ad1_params.Cw;
        ad_params.Cc = ad_params.Cc + ad1_params.Cc;
        ad_params.Cf = ad_params.Cf + ad1_params.Cf;
        ad_params.Ka = ad_params.Ka + ad1_params.Ka;
      end
    end

    % Multiply adjoints by covariances to get the matrix of representers
    % C*M'. Note, need to do some gymnastics to convert the params struct to
    % a vector (and back). Note, parameters that were corrected in phase-1
    % assimilation (e.g., wave BCs) are not multiplied by covariance at this
    % time, that is done in the time loop below.
    Cparam=diag(params_std.^2);
    if(strcmp(bkgdn2.sedmodel,'vanderA'))
      if(isfield(bkgdn2.params,'Cc'))
        [ad_fv,ad_ks,ad_lambda,ad_n,ad_m,ad_xi,ad_alpha,ad_Cc,ad_Cf]=paramsHandler(1,bkgdn2.sedmodel,ad_params);
        ad_pp=[ad_fv; ad_ks; ad_lambda; ad_n; ad_m; ad_xi; ad_alpha; ad_Cc; ad_Cf];
      else
        [ad_fv,ad_ks,ad_lambda,ad_n,ad_m,ad_xi,ad_alpha]=paramsHandler(1,bkgdn2.sedmodel,ad_params);
        ad_pp=[ad_fv; ad_ks; ad_lambda; ad_n; ad_m; ad_xi; ad_alpha];
      end
    elseif(strcmp(bkgdn2.sedmodel,'dubarbier'))
      [ad_fv,ad_ks,ad_lambda,ad_Cw,ad_Cc,ad_Cf,ad_Ka]=paramsHandler(1,bkgdn2.sedmodel,ad_params);
      ad_pp=[ad_fv; ad_ks; ad_lambda; ad_Cw; ad_Cc; ad_Cf; ad_Ka];
    end
    tl_pp = Cparam*ad_pp;
    tl_params=paramsHandler(0,bkgdn2.sedmodel,tl_pp);
    tl_beta0       =Cbeta0*ad_beta0;
    tl_d50         =Cd50*ad_d50  ;

    % the following variables are considered deterministic (will not be
    % corrected), so their covariance is zero
    tl_h = zeros(modelnx,modelnt+1);
    tl_omega       =0*ad_omega   ;
    tl_tau_wind    =0*ad_tau_wind;
    tl_detady      =0*ad_detady  ;
    tl_d90         =0*ad_d90     ;

    % since tl_params is constant, we need only measure it once for the
    % observation we're considering.  Include here all parameters we will be
    % correcting in the update step, and this defines the order
    CMt(:,n,i)=[tl_pp; tl_beta0];

    % Run TL model forwards in time for full simulation period
    for n2=1:bathyobs(n).obsn
      bkgdn2=load([bkgdCacheDir '/bkgd' num2str(n2,'%04d') '.mat']);
      bkgdn2.h=bkgdn2.h+bkgdn2.tide;
      bkgdn2.hp=bkgdn2.hp+bkgdn2.tide;
      [tl_Hrms,tl_vbar,tl_theta,tl_kabs,tl_Qx,tl_h(:,n2+1)] = ...
          tl_hydroSedModel(tl_h(:,n2),...
                           bkgdn2.CH0*ad_H0(n2),...
                           bkgdn2.Ctheta0*ad_theta0(n2),...
                           tl_omega(n2),...
                           bkgdn2.Cka*ad_ka_drag(n2),...
                           tl_beta0,...
                           tl_tau_wind(:,:,n2),...
                           tl_detady(:,n2),...
                           bkgdn2.Cgamma*ad_dgamma(:,n2),...
                           bkgdn2.CdAw*ad_dAw(:,n2),...
                           bkgdn2.CdSw*ad_dSw(:,n2),...
                           tl_d50,tl_d90,tl_params,bkgdn2);
    end  % TL forward time loop (index n2)

    % measure the TL output to get representers for observation (n,i)
    MCMt_thisn{i} = tl_h(bathyobs(n).measind,[bathyobs.obsn]+1);

    % use parforCounterFile to keep track of parfor progress
    unix(['echo ' num2str(i) ' >> ' parforCounterFile]);
    ndone = numel(textread(parforCounterFile,'%1c%*[^\n]'))-1;  % number of lines in file
    percdone=ndone/obsno*100;  % percent done
    elapsed=(now-starttime)*24*60;  % minutes
    eta=elapsed/percdone*(100-percdone);  % minutes remaining
    disp(['  ' num2str(percdone,'%.1f') '% Done.' ...
          '  Elapsed: ' num2str(elapsed,'%.1f') ' minutes,' ...
          '  ETA: ' num2str(eta,'%.1f') ' minutes.'])

  end  % loop (index i) over observations at time n
  unix(['rm -f ' parforCounterFile]);  % clean up

  % weird variable MCMt_thisn{i}(n,i) was needed to get parfor to run.  Unpack
  % it now.
  for i=1:obsno
    MCMt(n,i,:,:)=MCMt_thisn{i}';
  end

  disp(['  step ' num2str(n) ' finished in ' num2str(toc) 'sec'])
end  % bathyobs time loop (index n)

% measure the "forecast" bathymetry, based on TL-extrapolation from prior,
% linearized around the current bkgd.
if(~strcmp(priorCacheDir,bkgdCacheDir))
  disp(['Running forecast = bkgd + TL...'])
  tl_h = zeros(modelnx,modelnt+1);  % init
  tl_H0 = 0;
  tl_theta0 = 0;
  tl_omega = 0;
  tl_ka_drag = 0;
  tl_tau_wind = zeros(modelnx,2);
  tl_detady = zeros(modelnx,1);
  tl_dgamma = zeros(modelnx,1);
  tl_dAw = zeros(modelnx,1);
  tl_dSw = zeros(modelnx,1);
  tl_d50 = zeros(modelnx,1);
  tl_d90 = zeros(modelnx,1);
  bkgd1_prior=load([priorCacheDir '/bkgd0001.mat']);  % prior at time n=1
  bkgd1      =load([bkgdCacheDir  '/bkgd0001.mat']);  % current-iteration bkgd at time n=1
  tl_params.fv    =bkgd1_prior.params.fv    -bkgd1.params.fv    ;
  tl_params.ks    =bkgd1_prior.params.ks    -bkgd1.params.ks    ;
  tl_params.lambda=bkgd1_prior.params.lambda-bkgd1.params.lambda;
  if(strcmp(bkgd1.sedmodel,'vanderA'))
    tl_params.n    =bkgd1_prior.params.n    -bkgd1.params.n    ;
    tl_params.m    =bkgd1_prior.params.m    -bkgd1.params.m    ;
    tl_params.xi   =bkgd1_prior.params.xi   -bkgd1.params.xi   ;
    tl_params.alpha=bkgd1_prior.params.alpha-bkgd1.params.alpha;
    if(isfield(bkgd1.params,'Cc'))
      tl_params.Cc   =bkgd1_prior.params.Cc   -bkgd1.params.Cc   ;
      tl_params.Cf   =bkgd1_prior.params.Cf   -bkgd1.params.Cf   ;
    end
  elseif(strcmp(bkgd1.sedmodel,'dubarbier'))
    tl_params.Cw=bkgd1_prior.params.Cw-bkgd1.params.Cw;
    tl_params.Cc=bkgd1_prior.params.Cc-bkgd1.params.Cc;
    tl_params.Cf=bkgd1_prior.params.Cf-bkgd1.params.Cf;
    tl_params.Ka=bkgd1_prior.params.Ka-bkgd1.params.Ka;
  end
  tl_beta0=bkgd1_prior.beta0-bkgd1.beta0;
  for n2=1:modelnt
    if(floor(n2/modelnt*10)>floor((n2-1)/modelnt*10))
      disp([num2str(floor(n2/modelnt*100)) '%'])
    end
    bkgdn2=load([bkgdCacheDir '/bkgd' num2str(n2,'%04d') '.mat']);  % current-iteration bkgd struct
    bkgdn2.h=bkgdn2.h+bkgdn2.tide;
    bkgdn2.hp=bkgdn2.hp+bkgdn2.tide;
    [tl_Hrms,tl_vbar,tl_theta,tl_kabs,tl_Qx,tl_h(:,n2+1)] = ...
        tl_hydroSedModel(tl_h(:,n2),...
                         tl_H0,...
                         tl_theta0,...
                         tl_omega,...
                         tl_ka_drag,...
                         tl_beta0,...
                         tl_tau_wind,...
                         tl_detady,...
                         tl_dgamma,...
                         tl_dAw,...
                         tl_dSw,...
                         tl_d50,tl_d90,tl_params,bkgdn2);
  end
  for n=1:length(bathyobs)
    thisn=bathyobs(n).obsn;
    thisind=bathyobs(n).h.ind;
    thisbkgd=load([bkgdCacheDir '/bkgd' num2str(thisn,'%04d') '.mat']);
    Mf(n,:) = thisbkgd.hp(thisind) + tl_h(thisind,thisn+1);
  end
else
  disp(['Found prior==bkgd, hence using bkgd as forecast state (skipping TL-forecast step)'])
  for n=1:length(bathyobs)
    thisbkgd=load([bkgdCacheDir '/bkgd' num2str(bathyobs(n).obsn,'%04d') '.mat']);
    Mf(n,:)=thisbkgd.hp(bathyobs(n).h.ind);
  end
end

% unpack observations for all obs times
for n=1:obsnt
  d (n,:)=bathyobs(n).h.d;  % (nt,no) x 1
  Cd(n,:)=bathyobs(n).h.e.^2;  % (nt,no) x 1
end

% reshape matrices s.t. observations are treated as one big vector
CMt =reshape(CMt ,[modelnp obsnt*obsno]);  % np x (nt,no)
MCMt=reshape(MCMt,[obsnt*obsno obsnt*obsno]);  % (nt,no) x (nt,no)
Mf  =reshape(Mf  ,[obsnt*obsno 1]);  % (nt,no) x 1
d   =reshape(d   ,[obsnt*obsno 1]);  % (nt,no) x 1
Cd  =reshape(Cd  ,[obsnt*obsno 1]);  % (nt,no) x 1

% assimilation step, update the parameters
ind=find(~isnan(d));
update=CMt(:,ind)*inv(MCMt(ind,ind)+diag(Cd(ind)))*(d(ind)-Mf(ind));
bkgd1_prior=load([priorCacheDir '/bkgd0001.mat']);
params0=bkgd1_prior.params;
params.fv   =params0.fv   +update(1);
params.ks   =params0.ks   +update(2);
params.lambda=params0.lambda+update(3);
if(strcmp(bkgd1.sedmodel,'vanderA'))
  params.n    =params0.n    +update(4);
  params.m    =params0.m    +update(5);
  params.xi   =params0.xi   +update(6);
  params.alpha=params0.alpha+update(7);
  if(isfield(params0,'Cc'))
    params.Cc   =params0.Cc   +update(8);
    params.Cf   =params0.Cf   +update(9);
  end
elseif(strcmp(bkgd1.sedmodel,'dubarbier'))
  params.Cw = params0.Cw + update(5);
  params.Cc = params0.Cc + update(6);
  params.Cf = params0.Cf + update(7);
  params.Ka = params0.Ka + update(8);
end
params.beta0=bkgd1_prior.beta0+update(end);  % tacked-on for i/o convenience, even though is not a "sediment" parameter

% pack output struct with assimilation diagnostics
if(nargout==2)
  diagnostics.CMt    =CMt    ;
  diagnostics.MCMt   =MCMt   ;
  diagnostics.Mf     =Mf     ;
  diagnostics.d      =d      ;
  diagnostics.Cd     =Cd     ;
  diagnostics.update =update ;
  diagnostics.params0=params0;
  diagnostics.params_std=params_std;
end
